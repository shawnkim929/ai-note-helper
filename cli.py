#!/usr/bin/env python3

"""
The main CLI entrypoint.

Commands:
 - scan:       run linters and scan/replace directives in one pass through the file
 - watch:      watch a .tex and scanning on file writes/saves
 - apply:      apply the generated diff
"""

from pathlib import Path
import time
import typer
from rich.console import Console
from rich.panel import Panel

from ainote.latex.parser import find_directives, replace_generated_blocks
from ainote.latex.checks import run_checks
from ainote.suggestions.renderer import write_suggestions_md
from ainote.ai.provider import get_provider
from ainote.latex.edits import build_replacements_with_diff, apply_unified_diff

app = typer.Typer(help="Your AI note assistant")
console = Console()



# This is to avoid races with latexmk/temp writes
def _debounce_sleep():
    time.sleep(0.8) 



@app.command()
def scan(tex_file: str, apply: bool = typer.Option(False, help="Apply AI insertions when directives request to apply=true")):

    """
    Run linters and process inline AI directives through a single pass.
    """

    path = Path(tex_file)

    if not path.exists():
        raise typer.BadParameter(f"File not found: {path}")

    src = path.read_text(encoding="utf-8", errors="ignore")

    # 1) Deterministic checks and suggestions

    checks = run_checks(src)
    suggestions_path = write_suggestions_md(path, checks)
    console.print(Panel.fit(f"[bold]Suggestions written:[/bold] {suggestions_path}"))

    # 2) Look for any directives

    directives = find_directives(src)

    if not directives:
        console.print("[green]No AI directives found.[/green]")
        return

    console.print(f"[cyan]Found {len(directives)} AI directive(s).[/cyan]")

    # 3) Optionally resolve directives and handle prompting

    provider = get_provider()  # reads from env/config
    replacements = []

    for d in directives:

        if d.apply or apply:

            # System prompt used for handling the directives

            sys_prompt = (
                "You are assisting in writing rigorous university-level math notes in LaTeX. "
                "Be concise, correct, and avoid stating unproven claims. If unsure, say so. "
                "Maintain LaTeX-friendly output. Never invent citations."
            )

            out = provider.complete(prompt=d.instruction, sys_prompt=sys_prompt, max_tokens=d.max_tokens or 300, temperature=0.2)
            replacements.append((d, out))

        else:
            console.print(f" - [yellow]Skipping[/yellow] {d.verb} at line {d.line_no} (apply=false)")

    if not replacements:
        return

    # 4) Unify the changes from the applied directives and the original source into a separate difference file, plus including .undo

    diff_path, undo_path, new_text = build_replacements_with_diff(src, replacements, path)
    console.print(f"[bold]Diff:[/bold] {diff_path}")
    console.print(f"[bold]Undo patch:[/bold] {undo_path}")

    # 5) Write changes to file

    path.write_text(new_text, encoding="utf-8")
    console.print("[green]File updated with AI blocks.[/green]")



@app.command()
def watch(tex_file: str):

    """
    Watch a .tex file and re-run scan on writes.
    Debounced to avoid conflict with the LaTeX compiler.
    """

    path = Path(tex_file)

    if not path.exists():
        raise typer.BadParameter(f"File not found: {path}")

    console.print(f"Watching {path} (Ctrl+C to stop)...")
    mtime = path.stat().st_mtime

    try:

        while True:
            time.sleep(0.3)
            new_mtime = path.stat().st_mtime

            if new_mtime != mtime:
                mtime = new_mtime
                _debounce_sleep()

                try:
                    scan(str(path))

                except Exception as e:
                    console.print(f"[red]Error during scan:[/red] {e}")

    except KeyboardInterrupt:
        console.print("\n[cyan]Stopped watching.[/cyan]")



@app.command()
def apply(patch_file: str, tex_file: str):

    """
    Apply and replace the current file with the difference file generated by scan containing the applied directives. 
    This also supports .undo.patch.
    """

    path = Path(tex_file)
    patch = Path(patch_file)

    if not (path.exists() and patch.exists()):
        raise typer.BadParameter("tex_file or patch_file not found.")

    new_text = apply_unified_diff(path.read_text(encoding="utf-8"), patch.read_text(encoding="utf-8"))
    path.write_text(new_text, encoding="utf-8")
    console.print("[green]Patch applied.[/green]")



if __name__ == "__main__":
    app()
